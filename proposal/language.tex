
There are traditionally two styles of programming that are considered declarative.
Functional programming uses functions as an abstraction to encourage higher order reasoning.
Logic programming uses relations as an abstraction to encourage relational thinking.
Curry is an attempt to unify both of these approaches as a functional logic language.

Curry is by no means the first language to integrate the ideas of functional and logic programming.
On the logic side, Mercury \cite{} and HAL \cite{} included a type system and higher order functions;
Caio \cite{}, a dialect of Prolog, added notation for functions;
OZ \cite{} also included support for both funcitonal and logic programming;
and the Toy programming language \cite{} adds support for lazy functional logic programming in a prolog-like syntax.
Curry \cite{} is a modern functional logic language with Haskell-like syntax.

While Curry is syntactically similar to Haskell, there are a few important changes to the semantics.
The first, and most important, is that Curry computes by narrowing instead of rewriting.
These terms will be defined formally later, but the effect is that the order of equation definitions does not matter
in Curry as it does in Haskell.
This allows us to write non-deterministic functions in Curry.

Consider the code:
\begin{verbatim}
fac 0 = 1
fac n = n * fac (n-1)
\end{verbatim}

In Haskell, this is a reasonable definition of the factorial funciton; however, this definition does not work in Curry.
If the argument is \texttt 0, then the first equation will be selected in Haskell.
However, both equations will be selected in Curry.  This means that this definition will never terminate.

There is one important non-deterministic function in Curry.
The \texttt{?} function will non-deterministically select one of its two operands.
We define the function as

\begin{verbatim}
x ? y = x
x ? y = y
\end{verbatim}

This function allows us to construct non-deterministic expressions without defining new functions.
It will be used repeatedly throughout the rest of this proposal.

We further extend non-determinism with free variables.
A free variable is not given a value in the function, however its value may be constrained.

Consider the function:
\begin{verbatim}
last xs
 | (ys++[y]) == xs = y
  where y, ys free
\end{verbatim}

The variables \texttt{ys} and \texttt y are free, so their value is not determined.
However we made the constraint that \texttt{ys ++ [y]} is equal to the input.
This ensures that \texttt y is the final element of the list.

A final extension from Haskell to Curry is that expressions are allowed to fail.
An expression fails if it cannot produce a value.
For example \texttt{head []} will fail, because you cannot take the head of an empty list.
If we have a non-deterministic expression \texttt{a ? b} and \texttt a fails, then Curry will only return the result of \texttt b.

There are many other extensions to Curry including functional patterns, default rules, and set functions, however
these can be converted to standard Curry, so they are not relavant to this thesis.


\subsection{Evaluation}

In order for Curry to be a useful programming language, we must be able to run Curry programs.
The theory of functional logic programming is rooted firmly in term rewriting \cite{}, and graph rewriting \cite{} in particular.
Rewriting is a purely syntactic system for transforming expressions based entirely on a set of \textit{rewrite rules}.
In Curry, the rewrite rules correspond to the functions.
As an example, if we have \texttt{reverse [1,2] ++ reverse [3,4]},
then this can rewrite to \texttt{[2] ++ reverse [1] ++ reverse [3,4]}.
Rewriting continues until the expression is in a \textit{normal form}, a form in which no more rewriting can be done.
There are many questions at this point.  What happens if more than one possible rewrite rule applies?
What happens if two terms share a variable when rewriting?  What happens if there is no normal form?
We are going to sidestep all of these questions, and use an established rewriting strategy for Curry programs.

Curry programs are evaluated using the \textit{needed narrowing} rewriting strategy.
This strategy is lazy, because we don't rewrite an expression until it is required.
It has also been shown to be optimal in the number of rewrite steps \cite{Needed}.

An expression in Curry is a graph, where each node has a name, an arity (number of arguments),
and a set of children.
The number of children will match the arity of each node.
For example a \texttt{++} node will have two children, while a constant such as \texttt{pi} will have zero children.
We divide the set of nodes into three categories:
function symbols, nodes that have a rewrite rule; constructors, nodes that don't have a rewrite rule; and variables.
We can think of constructors as constructing data structures, like they do in Java, but that isn't relevant to the theory.

A Curry program is a set of functions, where each function is defined by equations.
These equations define the rewrite rules for that function.
A rewrite rule consists of a function symbol, zero or more parameters, and an expression to rewrite to, which is known as the contractum.
When rewriting a function symbol, we look up the corresponding equation, 
find a rule that applies, and replace the function symbol with that rule's contractum.
We determine which rules apply through pattern matching.

The needed narrowing strategy gives us the process for selecting the correct rule.
The basic idea is to construct a pattern matching tree out of all of the rules for a function.
Each branch of the tree contains a pattern position in an expression where the pattern match will occur.
Every child of the branch will either be a possible constructor, a failure, or a rewrite rule.
This allows us to rewrite an expression simply by traversing the tree.
This is known as a definitional tree.
The details of this construction can be found in \cite{defTree}

As an example, consider the rules for append:
\begin{verbatim}
append [] ys = ys
append (x:xs) ys = x : append xs ys
\end{verbatim}

\noindent
The definitional tree would be 

put picture of tree here.

\noindent
This makes the definition of evaluation very simple:

\begin{verbatim}
eval(e)
  if e is a normal form
    return e

  if e = C(x1,x2,... xn) where C is a constructor
    return C (eval c1) (eval x2) ... (eval xn) 

  if e = f(x1,x2,... xn) where f is a funciton symbol
    match x1,x2, ... xn on f's definitional tree
    rewrite f with all rules that apply
    return a copy for each rule that applied
\end{verbatim}

This is a very naive way to interpret a Curry program.
This compiler does no work to make sure that expressions are evaluated efficiently,
or even that terminating expressions will produce an answer.
There has been some work to use other compiler to optimize Curry programs.
Unfortunately, this has led to mixed results.
