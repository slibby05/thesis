
Logic programming has largely been more concerned with issues of completeness and soundness rather than efficiency.
While there are optimizing compilers for logic languages, most of the research is concerned with semantics and features.

While there were logic systems such as QA3 and Planner \cite{history_LP}, 
the first real logic programming language was Prolog \cite{prolog}.
Prolog, and logic languages in general, are distinct from other programming languages because they
handle control flow themselves.
There is debate about whether this is the correct way to program, or if the user should specify the control \cite{history_LP,planner},
but this is not relevant for this thesis.

While optimizing compilers for Prolog existed \cite{dec}, most modern implementations of Prolog 
use Warren's Abstract Machine (WAM) \cite{wam}
to define semantics, and optimizations for Prolog \cite{yap, sicstus}.
It is notable that the WAM consists of instructions to manipulate graphs in a heap, procedure calls, and backtracking.

The Mercury language added types, and the ability to control non-determinism and free variable instantiation \cite{mercury}.
This control of free variables, which they call modes, allows for many optimizations
that aren't possible in Prolog \cite{mercury}.
The Oz language focuses on Data Parallelism and constraint programming.
While Oz is a logic programming language, it is meant to be a multi-paradigm language.
As such, it is not surprising that its implementations tend to be slower than Mercury \cite{mercury, oz}

