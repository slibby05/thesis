while working on the a-normal form for curry, I had a couple of ideas for optimizations that I don't think anyone has done yet.
I also need a place to sketch out what the transformation will look like, so I'll do that here.

The basic idea is that all arguments to functions are variables or in head normal form
That way a function application is really simple.

the transformation ends up adding a lot of simple let expressions

example:
add (fac 10) (fac 2)
becomes
let f10 = fac 10
    f2  = fac 2
    in add f10 f2

This still works if we have a choice

fib (fac x ? add x x) where x = 15
will become
let x = 15
    facx = fac x
    addx = add x x
    orx = fibx ? addx
    in fib orx

One thing we would like to do is strictness analysis.
If we know that fib is going to use both of it's arguments, then they don't need to be thunks.
We can evaluate them eagerly.

We can potentially use this to remove some non-determinism

Suppose we have
let x = a ? failed in ...
In this case it's clear that we could replace this with
let x = a in ...

It's also true that, given f x
if f is strict in x, and x = failed, then f will evaluate to failed

Using this we can do a "failure propogation"
Ok, so this is just constant propagation with failure, but it's still useful
any function that is strict in failed is replaced by failed
any choice where failed is an option is removed

This is nice because it even works with shared variables.
Since the failure is only propagated through strict functions we don't have to worry about sharing
