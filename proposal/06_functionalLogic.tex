
While there have been many attempts to add functions to logic programming languages,
the idea of combining the two paradigms with a single formalism is fairly recent.
Most previous attempts were focusing on either adding functions to logic programming languages,
or adding non-determinism and logic variables to functional programming languages.
This often involved transforming one set of features into another.
While this can work, the theory is messy.

Modern functional logic languages attempt to unify the two concepts from the ground up.
Functional logic programs are thought of as term, and graph, rewrite system.
Computation in functional logic programs is done through narrowing.
There has been a lot of research into devising an optimal narrowing strategy;
however, there has been little work done on optimizing programs themselves.

One of the first functional logic languages is ALF \cite{alf}.
ALF integrates functional and logic programming using a graph rewrite system.
Computations in ALF use innermost narrowing, which is similar to eager evaluation.
ALF also had several restrictions. 
For example, functions had to be confluent and terminating.
ALF compiled to a variant of the WAM, 
although there was no attempt at making ALF-specific optimizations.

KLEAF took a different approach, and compiled to a flat intermediate language, 
and then used SLD-resolution to compute answers \cite{kleaf}.
The advantage is that KLEAF was able to compute more programs than ALF could.
In addition to the programs of ALF,
KLEAF could also compute non-terminating, locally confluent systems.
It also had very limited support for lazy evaluation.

Babel introduced lazy evaluation to functional logic programming \cite{babel}.
Similar to ALF, babel programs were computed with graph rewriting. 
However, babel compiled to an abstract graph rewriting machine.

The LIFE programming language combined logic programming, functional programming,
and object oriented programming. \cite{life}
While the object oriented programming isn't relevant, life also introduced a method
for suspending evaluation of equations until enough information had been determined
to resolve the equation.  This method, known as residuation, is one of the features of Curry.

The Toy language was an attempt to construct a lazy functional logic language \cite{toy}.
Syntactically Toy is similar to Prolog, and it uses a lazy narrowing strategy.
Toy is similar to Curry in many respects, but it is no longer under active development.

